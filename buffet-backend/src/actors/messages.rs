// Common message types for actor communication
use serde::{Deserialize, Serialize};

/// Common result type for actor messages
pub type ActorResult<T> = Result<T, ActorError>;

/// Common error type for actor operations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ActorError {
    /// Database operation failed
    DatabaseError(String),
    /// TSDB operation failed
    TsdbError(String),
    /// Invalid input or configuration
    InvalidInput(String),
    /// Actor not found or unavailable
    ActorUnavailable(String),
    /// Operation timed out
    Timeout,
    /// Internal error
    Internal(String),
}

impl std::fmt::Display for ActorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ActorError::DatabaseError(msg) => write!(f, "Database error: {}", msg),
            ActorError::TsdbError(msg) => write!(f, "TSDB error: {}", msg),
            ActorError::InvalidInput(msg) => write!(f, "Invalid input: {}", msg),
            ActorError::ActorUnavailable(msg) => write!(f, "Actor unavailable: {}", msg),
            ActorError::Timeout => write!(f, "Operation timed out"),
            ActorError::Internal(msg) => write!(f, "Internal error: {}", msg),
        }
    }
}

impl std::error::Error for ActorError {}

/// Reference to a time-series in the TSDB
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TimeSeriesRef {
    /// Measurement name in TSDB
    pub measurement: String,
    /// Tags for filtering
    pub tags: Vec<(String, String)>,
    /// Start time of the series
    pub start_time: chrono::DateTime<chrono::Utc>,
    /// End time of the series
    pub end_time: chrono::DateTime<chrono::Utc>,
}

impl TimeSeriesRef {
    pub fn new(
        measurement: String,
        tags: Vec<(String, String)>,
        start_time: chrono::DateTime<chrono::Utc>,
        end_time: chrono::DateTime<chrono::Utc>,
    ) -> Self {
        Self {
            measurement,
            tags,
            start_time,
            end_time,
        }
    }
}

/// Request to create an order
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrderRequest {
    pub signal_id: String,
    pub symbol: String,
    pub side: crate::models::order::OrderSide,
    pub quantity: f64,
    pub price: Option<f64>,
}

/// Order status update
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrderUpdate {
    pub order_id: String,
    pub status: crate::models::order::OrderStatus,
}

/// Signal generated by a strategy
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct Signal {
    pub strategy_id: String,
    pub symbol: String,
    pub signal_type: SignalType,
    pub timestamp: chrono::DateTime<chrono::Utc>,
    pub metadata: Option<String>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum SignalType {
    Buy,
    Sell,
    Hold,
}

impl std::fmt::Display for SignalType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SignalType::Buy => write!(f, "buy"),
            SignalType::Sell => write!(f, "sell"),
            SignalType::Hold => write!(f, "hold"),
        }
    }
}

/// Market data update message
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarketDataUpdate {
    pub symbol: String,
    pub data: crate::models::market_data::OHLCV,
}

/// Request to run a backtest
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RunBacktest {
    pub backtest_id: String,
}
